## 计算机网络

RFC（Request For Comments）技术文档（http://www.ietf.org/rfc.html）

1. TCP

   三次握手/四次挥手/滑动窗口: 流量控制/

   **TCP三次握手**

   主机A，和tcp服务器B。首先，主机A会给服务器B发送一条tcp建立连接的请求，包含同步位SYN = 1，随机序列号seq = x， 进入SYN-SENT状态；第二，（服务器始终是监听状态）服务器若正常接受这条数据，则会返回一个确认连接数据，其中包含同步位SYN=1，确认位ACK=1，ack = x+1(表示已经接受x之前的数据，请求发送接下来的数据)，以及当前的序列号seq = y， 进入SYN-RECEIVED状态; 第三，为了防止丢包造成服务器的持续等待从而浪费网络资源，则还需发送一条数据，包含 确认位ACK = 1， ack = y+1， seq =x+1;进入ESTABLISHED状态，完成建立。

   三次握手中的问题：

   1. 二次握手的问题：第一种：第一次握手失败，如超时到达，连接会被超时建立，浪费资源；第二种，第二次握手失败，主机一直处理等待状态，资源浪费。这也是第三次握手的原因
   2. 第三次握手失败：服务器超时重传，默认5次；若客户端给服务器发送时，服务器此时已经进入closed状态，则会以RST包应答
   3. 四次握手：可以但没必要
   4. 客户端故障了怎么办：服务器在每收到一次客户端请求都会重新复位一个计时器，一般是2小时，若两小时还没什么数据，则会发送探测报文，75s一次，连续十次无反应则判断客户端故障。
   5. Seq：32为序列号作为初始序列号， 判定合法数据

   

   **TCP四次挥手**

   首先，tcp客户端向tcp服务器端发送断开连接请求，这条数据将终止位FIN置为1,ACK=1，seq=u，ack=v，随即进入终止等待1状态；第二次， 服务器若正常接受，则返回一条确认收到数据，包含ACK=1 ,seq = v，ack =u+1，这个时候服务器端进入关闭等待，客户端成功接受这条数据后，则进入终止等待2状态，此时客户端没有数据要发送了，但是仍可以发送； 第三次，服务器将FIN=1，seq=w，ack=u+1发送给客户端，进入最后确认阶段；第四次，客户端接受到该条数据后，会返回一条ACK=1,seq=u+1，ack=w+1，进入TIME-WAIT时间等待阶段，服务器端正常接受这条命令后就进入closed状态，客户端等待2个MSL（报文段最长寿命）时间后，也进入closed状态。此时，四报文挥手完成。

   1. 服务器端close-wait状态的意义：服务器接受到关闭请求时可能还有数据需要发送，这时候先回复ACK，表示接受请求。
   2. 第二次失败：超时重传，重发FIN=1数据
   3. 第四次问题：客户端TIME-WAIT是为了防止第四次丢失，从而进行重传

   

   **TCP流量控制**

   流量控制的目的是防止发送方发送速率过快，这时候数据的接收方会维护一个接收窗口，来表示自己还能接受多少数据，接收窗口会动态调整，发送方的数据不能超过这个窗口的大小，发送窗口的上限为接受窗口和拥塞窗口（表达网络传输数据的能力）中的较小值。

   当rwnd=0时：发送方会启动一个持续计时器，到期后，则会发送一个大小为1字节的探测包，来查看接受窗口状态。

   

   **TCP拥塞控制**

   - 慢开始算法、拥塞避免、快重传、快恢复

   刚开始发送数据时，拥塞窗口大小为1MSS，每收到一个新的新的确认报文，拥塞窗口就+1，当达到ssh门限时，执行拥塞避免算法，开始线性增长，一轮次只增加一个MSS。当检测到网络拥塞时(判断依据为没有收到确认)，则将ssh设为拥塞窗口的一半，再将拥塞窗口重新设置为1。若使用快重传，当收到一个失序报文段，则立即发出重复确认，发送方收到连续3次重复确认，则立即重发失序片段，而无需等到重传计时器到期。（快恢复：三次确认都能收到，说明不堵）将ssh减半或将ssh+3。

   

   **TCP如何保证传输的可靠性**

   1. 数据包校验
   2. 对失序数据包重新排序（TCP报文具有序列号）
   3. 丢弃重复数据
   4. 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；
   5. 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；
   6. 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出

   

   **TCP如何最大利用带宽**？

   TCP速率受到三个因素影响

   - 窗口：即华东窗口大小
   - 带宽：即从发送端到接收端所能通过的最高数据率，是一种硬件限制
   - RTT：即数据包一去一回所需的时间，TCP会在传输过程中对RTT进行采样，根据测量值更新RTT值，TCP根据得到的RTT值更新RTO（retransmission timeout 重传间隔），发送端对每个发出的数据包进行计时，如果在RTO时间没有收到所发数据包对应的ACK，则任务数据丢失，将重传数据。一般，采样的RTO值都比RTT值要大

   

   **带宽时延乘积**

   带宽时延乘积=带宽*RTT	

   理想情况：最大速度是V = W/T (W是滑动窗口数据，T是RTT)

   结合带宽：0.5*B*T （B为带宽）

   

2. TCP/UDP

   - 面向连接/无连接

   - 可靠传输，使用流量控制和拥塞控制/不可靠传输

   - 一对一通信/支持一对一，一对多，多对一和多对多交互通信

   - 面向字节流/ 面向报文

   - 首部最小20字节，最大60字节/首部开销小，仅8字节

   - 适用于要求可靠传输的应用，例如文件传输/适用于实时应用（电话、视频、直播等）

   - udp主机不需要维持复杂的连接状态表

     

3. 面向连接和无连接的区别

   无连接的网络服务（数据报服务）-- 面向连接的网络服务（虚电路服务）

   虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；

   数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；

   

4. GET/POST

   - GET一般用于**查询**信息，POST一般用于提交某种信息进行某些**修改**操作

   - GET在浏览器**回退**不会再次请求，POST会再次提交请求

   - GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；

   - GET请求会被浏览器主动**缓存**，POST不会，要手动设置

   - GET**请求参数**会被完整保留在浏览器历史记录里，POST中的参数不会

   - GET请求在URL中传送的参数是有**长度**限制的，而POST没有限制 

   - GET参数通过URL传递，POST放在Request body中

   - GET参数暴露在地址栏不**安全**，POST放在报文内部更安全 

   - GET产生一个TCP**数据包**；POST产生两个TCP数据包

     ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/14/168e9d9050b9d08a~tplv-t2oaga2asx-watermark.awebp)
     
     

5. http1.0/2.0

   - 1.0缺陷：短连接，线头阻塞

   - 1.1：长连接，身份认证，cache缓存，状态管理

   - 2.0：采用二进制格式，新增特性：多路复用，首部压缩，服务端推送

     

6. OSI七层模型/tcp五层模型

   物理层-数据链路层-传输层-网络层-应用层-会话层-表示层

   

7. http和https

   http:超文本传输协议，双向协议。

   http常见字段：Host(域名)，Content-length(数据长度)，connection(连接状态)，Content-Type(数据类型)

   https:http+SSL/TLS，需向CA申请数字证书，来保证服务器的身份是可信的。

   实现过程：

   1. 混合加密：在通信建立前采用非对称加密的方式交换会话秘钥，在通信过程中使用对称加密进行数据交换。 
   2. 摘要算法：明文和摘要进行加密解密，对比后能看出是否篡改。
   3. 数字证书

   TSL四次握手过程：

   1. 客户端发送Client Hello消息，明文传输，内容包含支持的协议、加密套件(认证算法、密钥交换算法、对称加密算法和信息摘要算法)、压缩方法、随机数R1
   2. 应对Client Hello，服务端发送Server Hello，明文传输，相应消息包括协议版本、随机数R2、加密套件、压缩方法；然后马上发送公钥证书给客户端；。。。；Server Hello Done。
   3. Client Key Exchange是指客户端将PreMaster Key发送给服务器，服务器能解密出PreMaster Key。然后双方都有R1、R2、PreMaster Key。这时用一个相同算法和这三个随机数生成一个密钥用于握手后的对称加密。
   4. Change Cipher Spec是服务器通知客户端，以后都用这个协商好的密钥进行加密。

   总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。摘要算法验证信息的完整性；数字签名进行身份验证。

   

   **HTTP和HTTPS有什么区别：**

   HTTP：支持c/s模式；简单快速；灵活：允许传输任意类型的数据对象 content-Type加以标记；无连接：每次只处理一个请求；无状态：无法根据之前的状态进行本次的请求处理

   1. 端口不同：HTTP使用的是80端口，HTTPS使用443端口；
   2. HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；
   3. HTTPS由于加密解密会带来更大的CPU和内存开销；
   4. HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买

   

   **对称加密和非对称加密**

   - 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4
   - 非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA
   - 区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）

   

   **数字签名和报文摘要的原理**

   - 发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。
   - 摘要算法:MD5、SHA

   

8. 常见协议

   - 应用层

     - FTP(21端口)：文件传输协议

     - SSH(22端口)：远程登陆

     - TELNET(23端口)：远程登录

     - SMTP(25端口)：发送邮件

     - POP3(110端口)：接收邮件

     - HTTP(80端口)：超文本传输协议

     - DNS(53端口)：运行在UDP上，域名解析服务、

       查询方式：递归查询（给结果）、迭代查询（给结果/无结果则返回查询路径）

       查询过程：

       1. 首先搜索浏览器中的DNS缓存，若无，则2
       2. 搜索操作系统中的DNS缓存，若无，则3
       3. 操作系统将域名发送至本地域名服务器，采用递归查询，若无，则4
       4. 本地域名服务器向根域名服务器，根域名服务器向顶级域名服务器
       5. 各部存储地址

   - 传输层(TCP/DP)

     - TCP(全双工)：SMTP(电子邮件)/TELNET(远程终端接入)/HTTP/FTP(文件传输)
     - UDP：DNS/TFTP(文件传输)/SNMP(网络管理)/NFS(远程文件服务器)

   - 网络层

     - IP

     - ARP：address resolution protocol,完成ip地址和物理地址的映射。

     - NAT：Network Address Translation, 网络地址转换，用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。

     - RIP

       Routing Information Protocol , 距离矢量路由协议，属于应用层协议

       优缺点：

       ​		实现简单，开销小；

       ​		但随着网络规模增大开销也会增大；

       ​		最大距离为15，限制了网络的规模

       ​		当网络出现故障时，要经过较长时间才能将此信息传递到所有路由器

     路由器属于网络层，根据IP地址进行寻址；交换机属于数据链路层，根据MAC地址进行寻址。

     

9. IP地址分类

10. uri和url的区别

   uri为统一资源定位符，某种网络资源的特有标识。URL为我们输入在浏览器的一串

























